#!/usr/bin/env python3

import json
import sys

## XXX TODO : create python enums for relkind, target...

prefix = """

// This stencil library was generated by stencil-builder.py
// Do not edit by hand, especially if you don't know what you are doing.

typedef enum Relkind {
    RELKIND_R_X86_64_64,
    RELKIND_REJUMP,
    RELKIND_R_AARCH64_MOVW_UABS_G0_NC,
    RELKIND_R_AARCH64_MOVW_UABS_G1_NC,
    RELKIND_R_AARCH64_MOVW_UABS_G2_NC,
    RELKIND_R_AARCH64_MOVW_UABS_G3,
    RELKIND_R_AARCH64_JUMP26,
    RELKIND_R_AARCH64_CALL26
} Relkind;

typedef enum Target {
    TARGET_CONST_ISNULL,
    TARGET_CONST_VALUE,
    TARGET_RESULTNUM,
    TARGET_ATTNUM,
    TARGET_OP,
    TARGET_NEXT_CALL,
    TARGET_FORCE_NEXT_CALL,
    TARGET_FUNC_CALL,
    TARGET_FUNC_INFO,
    TARGET_FUNC_NARGS,
    TARGET_FUNC_ARG,
    TARGET_JUMP_DONE,
    TARGET_JUMP_NULL,
    TARGET_RESULTSLOT_VALUES,
    TARGET_RESULTSLOT_ISNULL,
    TARGET_MakeExpandedObjectReadOnlyInternal,  // TODO : replace this and followings with a TARGET_FUNCTION_CALL and a Patch::function_name ?
    TARGET_slot_getsomeattrs_int,
    TARGET_ExecEvalScalarArrayOp,               // TODO : used as is, should be reimplemented but I wanted to show it can be quick this way
    TARGET_ExecEvalSysVar,                      // can it stay as is ?
    TARGET_ExecEvalSQLValueFunction,            // should be fine too
    TARGET_ExecEvalParamExec,                   // should be fine too
    TARGET_ExecEvalParamExtern,                 // should be fine too
    TARGET_CurrentMemoryContext,
} Target;

typedef struct Patch {
    const uint64_t offset; // Do we need length ?
    const Relkind relkind;
    const Target target;
    // Is it enough?
} Patch;

typedef struct Stencil {
    size_t code_size;
    const unsigned char *code;
    size_t patch_size;
    const Patch *patches;
} Stencil;


Stencil stencils[EEOP_LAST];
"""


## Not fond of this, it would be better as a fully static array. will do for now.
prefix_initializer = """
void initialize_stencils() {
    for (int i = 0 ; i < EEOP_LAST ; i++) {
        // mark all stencils as uninitialized
        stencils[i].code_size = -1;
    }
"""

postfix_initializer = "}"

class Patch(object):
    def __init__ (self, target, kind, offset):
        self.target = target
        # XXX FIXME this is lazy
        if self.target == "op":
            self.target = "OP"
        self.kind = kind
        self.offset = offset

    def dump_patch(self, out_fd):
        out_fd.write("{%s, RELKIND_%s, TARGET_%s}," % (self.offset, self.kind, self.target))

class Stencil(object):
    def __init__ (self, name, code, start, end, arch):
        self.name = name
        self.code = code
        self.start = start
        self.end = end
        self.arch = arch
        self.patches = []

    def add_patch(self, patch):
        self.patches.append(patch)
        patch.offset -= self.start

    def _strip_final_next_call(self):
        # first, find the NEXT_CALL patch
        next_call_patch = None
        used_targets = set()
        for patch in self.patches:
            used_targets.add(patch.target)
            if patch.target == "NEXT_CALL":
                next_call_patch = patch

        if next_call_patch is None:
            return

        if next_call_patch != self.patches[-1]:
            return

        if self.arch == "x86_64":
            # ok, so we must identify that pattern at patch.offset-2 : movabs $0x0,%rax ; jmp *%rax
            # aka 48 b8 00 00 00 00 00 00 00 00 ff e0
            amd64prefix = self.code[next_call_patch.offset - 2:next_call_patch.offset]
            amd64postfix = self.code[next_call_patch.offset + 8:next_call_patch.offset + 10]
            if amd64prefix == [0x48, 0xb8] and amd64postfix == [0xff, 0xe0]:
                # now we know where it ends : at patch.offset - 2
                self.code = self.code[:next_call_patch.offset - 2]
                self.patches = self.patches[:-1]
            # XXX TODO : extremely hazardous hack
            elif False and self.code[-2:] == [0xff, 0xe0] and not "TARGET_JUMP_DONE" in used_targets:
                # last opcode is jmp *rax, remove it because we should never jump somewhere else
                self.code = self.code[:-2]
        elif self.arch == "aarch64":
            ## if next call patch is in the last instruction, just remove it
            if next_call_patch.offset + 4 == len(self.code):
                self.code = self.code[:len(self.code) - 4]
                self.patches = self.patches[:-1]

    def strip_code(self):
        # first, try to get rid of final next_call
        self._strip_final_next_call()
        # and now for specific optimizations
        if self.arch == "x86_64":
            # now, try to find out a movabs XX, %rax ; jmp *%rax sequence
            mov_and_jmp = b"\x48\xb8\x00\x00\x00\x00\x00\x00\x00\x00\xff\xe0"
            patch_offset = 2
            code = bytes(self.code)
            while mov_and_jmp in code:
                idx = code.index(mov_and_jmp)
                # replace it with nops
                code = code[:idx] + b"\x90" * len(mov_and_jmp) + code[idx+len(mov_and_jmp):]
                # move the corresponding patch to the beginning of this beautiful hole
                for patch in self.patches:
                    if patch.offset == idx+patch_offset:
                        patch.offset = idx
                        patch.kind = 'REJUMP'
            self.code = [x for x in code]

    def dump_code(self, out_fd):
        out_fd.write("const unsigned char %s__code[%s] = {%s};\n" % (self.name, len(self.code), ", ".join([hex(x) for x in self.code])))

    def dump_patches(self, out_fd):
        if len(self.patches) == 0:
            out_fd.write("// No patch for %s\n" % self.name)
        else:
            out_fd.write("const Patch %s__patches[%s] = {" % (self.name, len(self.patches)))
            for patch in self.patches:
                patch.dump_patch(out_fd)
            out_fd.write("};\n")

    def dump_initializer(self, out_fd):
        if len(self.patches) == 0:
            out_fd.write("stencils[%s].code_size = %s; stencils[%s].code = %s__code; stencils[%s].patch_size = 0;\n" % (self.name, len(self.code), self.name, self.name, self.name))
        else:
            out_fd.write("stencils[%s].code_size = %s; stencils[%s].code = %s__code;\n" % (self.name, len(self.code), self.name, self.name))
            out_fd.write("stencils[%s].patch_size = %s; stencils[%s].patches = %s__patches;\n" % (self.name, len(self.patches), self.name, self.name))

class ExtraStencil(Stencil):
    def dump_initializer(self, out_fd):
        if len(self.patches) == 0:
            out_fd.write("struct Stencil %s = { .code_size = %s, .code = %s__code, .patch_size = 0; };\n" % (self.name, len(self.code), self.name))
        else:
            out_fd.write("struct Stencil %s = { .code_size = %s, .code = %s__code, .patch_size = %s, .patches = %s__patches };\n" % (self.name, len(self.code), self.name, len(self.patches), self.name))

def sections_iterator(sections, major):
    for section in sections:
        section = section["Section"]
        if major < 15:
            yield (section["Name"]["Value"], section)
        else:
            yield (section["Name"]["Name"], section)

def relocations_iterator(relocations, major):
    for relocation in relocations:
        relocation = relocation["Relocation"]
        if major < 15:
            yield (relocation["Type"]["Value"], relocation["Symbol"]["Value"], relocation["Offset"], relocation)
        else:
            yield (relocation["Type"]["Name"], relocation["Symbol"]["Name"], relocation["Offset"], relocation)

def symbols_iterator(symbols, major):
    for symbol in symbols:
        symbol = symbol["Symbol"]
        if major < 15:
            yield (symbol["Name"]["Value"], symbol["Value"], symbol["Size"], symbol)
        else:
            yield (symbol["Name"]["Name"], symbol["Value"], symbol["Size"], symbol)

def generate_stencil(readobj_major, in_filename, out_filename):
    objdump = json.load(open(in_filename, "r"))
    stencils_o = objdump[0]
    if readobj_major < 15 and type(stencils_o) == dict:
        stencils_o = stencils_o[list(stencils_o.keys())[0]]
    print(stencils_o.keys())
    arch = stencils_o["FileSummary"]["Arch"]
    stencils = []
    extra_stencils = []
    for (section_name, section) in sections_iterator(stencils_o["Sections"], readobj_major):
        if section_name == ".ltext":
            data = section["SectionData"]["Bytes"]
            print("iterating symbols")
            for (symbol_name, symbol_offset, symbol_size, symbol) in symbols_iterator(section["Symbols"], readobj_major):
                print("... symbol")
                if symbol_name.startswith("stencil_"):
                    print("iterating symbols => stencil")
                    end = symbol_offset + symbol_size
                    stencils.append(Stencil(symbol_name[8:], data[symbol_offset:end], symbol_offset, end, arch))
                elif symbol_name.startswith("extra_"):
                    print("iterating symbols => extra")
                    end = symbol_offset + symbol_size
                    extra_stencils.append(ExtraStencil(symbol_name, data[symbol_offset:end], symbol_offset, end, arch))
                else:
                    print(f"unknown symbol {symbolName}")


        if section_name == ".rela.ltext":
            for (relkind, target, code_offset, relocation) in relocations_iterator(section["Relocations"], readobj_major):
                patch = Patch(target, relkind, code_offset)

                # match the patch to a stencil
                for stencil in stencils + extra_stencils:
                    if stencil.start <= patch.offset and stencil.end > patch.offset:
                        stencil.add_patch(patch)
                        break
                else:
                    raise Exception("Patch not matched to a stencil")

    with open(out_filename, "w") as out_fd:
        out_fd.write(prefix)
        for stencil in stencils + extra_stencils:
            stencil.strip_code()
            stencil.dump_code(out_fd)
            stencil.dump_patches(out_fd)

        out_fd.write(prefix_initializer)
        for stencil in stencils:
            stencil.dump_initializer(out_fd)
        out_fd.write(postfix_initializer)
        for extra in extra_stencils:
            extra.dump_initializer(out_fd)

if __name__ == "__main__":
    # args readobj-version source.json target.c
    readobj_version = sys.argv[1]
    major_version = int(readobj_version.split('.')[0])
    filename = sys.argv[2]
    output = sys.argv[3]
    generate_stencil(major_version, filename, output)
