#!/usr/bin/env python3

import json
import sys

## XXX TODO : create python enums for relkind, target...

prefix = """

// This stencil library was generated by stencil-builder.py
// Do not edit by hand, especially if you don't know what you are doing.

typedef enum Relkind {
    RELKIND_R_X86_64_64,
} Relkind;

typedef enum Target {
    TARGET_CONST_ISNULL,
    TARGET_CONST_VALUE,
    TARGET_RESULTNUM,   // XXX specific to assign_tmp ?
    TARGET_OP,
    TARGET_NEXT_CALL,
    TARGET_JUMP_DONE,
    TARGET_MakeExpandedObjectReadOnlyInternal,  // TODO : replace with a TARGET_FUNCTION_CALL and a Patch::function_name
} Target;

typedef struct Patch {
    const uint64_t offset; // Do we need length ?
    const Relkind relkind;
    const Target target;
    // Is it enough?
} Patch;

typedef struct Stencil {
    size_t code_size;
    const unsigned char *code;
    size_t patch_size;
    const Patch *patches;
} Stencil;


Stencil stencils[EEOP_LAST];
"""


## Not fond of this, it would be better as a fully static array. will do for now.
prefix_initializer = """
void initialize_stencils() {
    for (int i = 0 ; i < EEOP_LAST ; i++) {
        // mark all stencils as uninitialized
        stencils[i].code_size = -1;
    }
"""

postfix_initializer = "}"

class Patch(object):
    def __init__ (self, target, kind, offset):
        self.target = target
        # XXX FIXME this is lazy
        if self.target == "op":
            self.target = "OP"
        self.kind = kind
        self.offset = offset

    def dump_patch(self):
        print("{%s, RELKIND_%s, TARGET_%s}," % (self.offset, self.kind, self.target))

class Stencil(object):
    def __init__ (self, name, code, start, end):
        self.name = name
        self.code = code
        self.start = start
        self.end = end
        self.patches = []

    def add_patch(self, patch):
        self.patches.append(patch)
        patch.offset -= self.start

    def strip_code(self):
        # first, find the NEXT_CALL patch
        next_call_patch = None
        for patch in self.patches:
            if patch.target == "NEXT_CALL":
                assert(next_call_patch is None)
                next_call_patch = patch

        if next_call_patch is None:
            return

        assert(next_call_patch == self.patches[-1])

        # XXX TODO : this is not portable at all yet.
        # ok, so we must identify that pattern at patch.offset-2 : movabs $0x0,%rax ; jmp *%rax
        # aka 48 b8 00 00 00 00 00 00 00 00 ff e0
        amd64prefix = self.code[next_call_patch.offset - 2:next_call_patch.offset]
        amd64postfix = self.code[next_call_patch.offset + 8:next_call_patch.offset + 10]
        if amd64prefix == [0x48, 0xb8] and amd64postfix == [0xff, 0xe0]:
            # now we know where it ends : at patch.offset - 2
            self.code = self.code[:next_call_patch.offset - 2]
            self.patches = self.patches[:-1]

    def dump_code(self):
        print("const unsigned char %s__code[%s] = {%s};" % (self.name, len(self.code), ", ".join([hex(x) for x in self.code])))

    def dump_patches(self):
        if len(self.patches) == 0:
            print("// No patch for %s" % self.name)
        else:
            print("const Patch %s__patches[%s] = {" % (self.name, len(self.patches)))
            for patch in self.patches:
                patch.dump_patch()
            print("};")

    def dump_initializer(self):
        if len(self.patches) == 0:
            print("stencils[%s].code_size = %s; stencils[%s].code = %s__code; stencils[%s].patch_size = 0;" % (self.name, len(self.code), self.name, self.name, self.name))
        else:
            print("stencils[%s].code_size = %s; stencils[%s].code = %s__code;" % (self.name, len(self.code), self.name, self.name))
            print("stencils[%s].patch_size = %s; stencils[%s].patches = %s__patches;" % (self.name, len(self.patches), self.name, self.name))

def generate_stencil(filename):
    objdump = json.load(open(filename, "r"))
    stencils_o = objdump[0]
    stencils = []
    for section in stencils_o["Sections"]:
        section = section["Section"]
        if section["Name"]["Value"] == ".text":
            data = section["SectionData"]["Bytes"]
            for symbol in section["Symbols"]:
                symbol = symbol["Symbol"]
                symbolName = symbol["Name"]["Value"]
                if symbolName.startswith("stencil_"):
                    # FUN
                    offset = symbol["Value"]
                    end = offset + symbol["Size"]
                    stencils.append(Stencil(symbolName[8:], data[offset:end], offset, end))

        if section["Name"]["Value"] == ".rela.text":
            data = section["SectionData"]["Bytes"]
            for relocation in section["Relocations"]:
                relocation = relocation["Relocation"]
                relkind = relocation["Type"]["Value"]
                target = relocation["Symbol"]["Value"]
                code_offset = relocation["Offset"]
                patch = Patch(target, relkind, code_offset)

                # match the patch to a stencil
                for stencil in stencils:
                    if stencil.start <= patch.offset and stencil.end > patch.offset:
                        stencil.add_patch(patch)
                        break

    print(prefix)
    for stencil in stencils:
        stencil.strip_code()
        stencil.dump_code()
        stencil.dump_patches()

    print(prefix_initializer)
    for stencil in stencils:
        stencil.dump_initializer()
    print(postfix_initializer)

if __name__ == "__main__":
    # args machin
    filename = sys.argv[1]
    generate_stencil(filename)
